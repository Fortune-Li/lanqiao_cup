# README

## 题目

### 问题描述
如果一个质数`P`的每位数字都是质数, 而且每两个相邻的数字组成的两位数是质数, 而且每三位相邻的数字组成的三位数是质数, 依次类推, 如果每相邻的`k` 位数字组成的`k`位数都是质数, 则`P`称为超级质数。

如果把超级质数`P`看成一个字符串, 则这个超级质数的每个子串都是质数。

例如, `53` 是一个超级质数。请问, 最大的超级质数是多少?

## 思考过程

1. **题目分析**：
   - 本题其实是质数排列组合问题由一位数扩展到更多位。10以内是质数的为2，3，5，7 以此继续扩展到两位数，甚至三位数。

2. **核心思路**：
    - 数字分解：检查数字`P`的每个子串是否是质数，首先要分解出`P`中的每个子串。例如，对于数字373，检查3、7、37、373这些数字是否都是质数。
    - 质数判断：对于每个分解出来的数字，需要判断它是否为质数。质数判断的效率直接影响到程序的执行时间。
    - 反转检查：反转数字是为了确保检查到所有可能的数字组合，而不仅仅是从左到右的顺序。因为题目并没有限制我们只考虑从左到右的顺序，所以要考虑数字的所有排列（包括反转后的排列），以确保它们符合超级质数的条件。

3. **关键步骤**：
    - 质数判断: 编写 `isPrime` 函数，从`2`到`sqrt(n)`遍历。
        - 推理过程：
            - 假设`𝑛`可以被某个`𝑑`整除，得到`𝑛=𝑑×𝑘`，那么`𝑑`和`𝑘`必定满足:`𝑑≤𝑘`或者`𝑘≤𝑑`。
            - 如果`𝑑`>`sqrt(𝑛)`，则`𝑘`<`sqrt(𝑛)`（因为`𝑑×𝑘=𝑛`）。所以，必须有一个因数`𝑑`或`𝑘`<=`𝑛`。
            - 这意味着，只需要检查小于或等于`sqrt(𝑛)`的所有数，如果在这个范围内没有找到能整除`𝑛`的数，说明`𝑛`是质数；否则,`𝑛` 就不是质数。

4. **优化建议**：
    - 减少反转计算：通过直接数学反转数字，避免了字符串转换的开销。
    ```cpp
        int reverse(int n)
        {
            int newNum = 0;
            while (n > 0)
            {
                newNum = newNum * 10 + (n % 10); // 每次提取最后一位并累加
                n /= 10; // 去掉最后一位
            }
            return newNum;
        }
