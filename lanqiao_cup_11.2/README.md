# README

## 题目

### 问题描述
小蓝在玩一个寻宝游戏，游戏在一条笔直的道路上进行。道路被分成了 `n` 个方格，依次编号为 1 至 `n`，每个方格上都有一个宝物，宝物的分值是一个整数（包括正数、负数和零）。当进入一个方格时，玩家会获得该方格中宝物的分值。小蓝可以获得的总分值是他从方格中获得的分值之和。

小蓝开始时站在方格 1 上并获得了方格 1 上宝物的分值，他要经过若干步到达方格 `n`。

当小蓝站在方格 `p` 上时，他可以选择跳到 `p+1` 到 `p + D(n - p)` 这些方格中的一个，其中 `D(x)` 表示 `x` 的最小质因数。

给定每个方格中的宝物分值，请问小蓝能获得的最大总分值是多少。

### 输入格式
- 第一行包含一个正整数 `n`，表示方格数。
- 第二行包含 `n` 个整数，依次表示每个方格中宝物的分值。

### 输出格式
输出一行包含一个整数，表示小蓝能获得的最大总分值。

### 样例输入
5  
1 -2 -1 3 5

### 样例输出
8

---

## 思考过程

1. **题目分析**：
   - 这个问题可以使用动态规划（DP）解决。
   - 目标是从方格 1 到方格 `n`，通过一定的跳跃，最大化得到的分数。
   - 每个方格的跳跃范围受其位置的最小质因数影响。我们需要在跳跃时考虑每个方格的最大分数。

2. **动态规划设计**：
   - 定义 `DP[i]` 为方格`1`到达方格 `i` 时能获得的最大分数。
   - 初始状态：`DP[1] = Arr[1]`，即从第一个方格开始时，最大分数就是该方格的分值。
   - 递推状态：对于每个方格 `i`，计算从当前方格 `i` 可以跳跃到哪些方格 `j`，并更新其最大分数。 
   - 终止条件：最终我们要求的是 `DP[n]`，即到达方格 `n` 时的最大分数。

3. **状态转移方程**:
    - 当小蓝站在方格 `i` 时，他有多个可能的跳跃目标，从 `i+1` 到 `i + D(n - i)`。其中 `i+D(n - i)` 表示当前方格 `i` 跳跃的最大步长。

    - 对于每一个可能的跳跃目标 `j`，我们希望知道，从方格 `i` 到 `j` 时，能获得的最大分数是多少。因为我们已经知道了从方格 `1` 到方格 `i` 时的最大分数 `DP[i]`，所以到达方格 `j` 时的分数应该是 `DP[i] + Arr[j]`，即从方格 `i` 到方格 `j` 时的最大得分。

    - `max(DP[j], DP[i] + Arr[j])` 的意思是：如果通过跳跃到 `j` 来得到的分数更大（即 `DP[i] + Arr[j]` 更大），我们就更新 DP[j] 的值，否则保持原有的 `DP[j]` 值。也就是说，`DP[j]` 总是存储到达方格 `j` 时的最大得分。

4. **关键步骤**：
   - `smallestPrimeFactor(x)` 函数用来计算给定位置 `x` 的最小质因数。
   - 计算跳跃范围时，从当前位置跳跃到当前方格 `i` 到 `i + D(i)` 之间的方格，并更新相应的最大分数。

5. **优化建议**：
   - 使用动态规划的 `DP` 数组来保存每个方格的最大分数，避免重复计算。

---